<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>YSW-NOTE</title>
    <meta name="description" content="晏沈威的笔记">
    <link rel="icon" href="/assets/logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2749efcc.css" as="style"><link rel="preload" href="/assets/js/app.2d4845b5.js" as="script"><link rel="preload" href="/assets/js/2.974af1fb.js" as="script"><link rel="preload" href="/assets/js/11.652fa16d.js" as="script"><link rel="prefetch" href="/assets/js/10.48cab603.js"><link rel="prefetch" href="/assets/js/12.b0608426.js"><link rel="prefetch" href="/assets/js/13.e9415f24.js"><link rel="prefetch" href="/assets/js/14.dde1bec7.js"><link rel="prefetch" href="/assets/js/15.8b695c03.js"><link rel="prefetch" href="/assets/js/16.647cd73d.js"><link rel="prefetch" href="/assets/js/17.af05518d.js"><link rel="prefetch" href="/assets/js/18.b0600c14.js"><link rel="prefetch" href="/assets/js/19.953b459c.js"><link rel="prefetch" href="/assets/js/20.e2a7f6e3.js"><link rel="prefetch" href="/assets/js/21.60a88409.js"><link rel="prefetch" href="/assets/js/22.d40553da.js"><link rel="prefetch" href="/assets/js/23.eea7414f.js"><link rel="prefetch" href="/assets/js/24.1c179723.js"><link rel="prefetch" href="/assets/js/25.a116c32f.js"><link rel="prefetch" href="/assets/js/26.93e18f12.js"><link rel="prefetch" href="/assets/js/27.e703db15.js"><link rel="prefetch" href="/assets/js/28.9d5a600f.js"><link rel="prefetch" href="/assets/js/29.ec56e0f7.js"><link rel="prefetch" href="/assets/js/3.b9e90bed.js"><link rel="prefetch" href="/assets/js/30.3419dbef.js"><link rel="prefetch" href="/assets/js/31.5541885c.js"><link rel="prefetch" href="/assets/js/4.383e9253.js"><link rel="prefetch" href="/assets/js/5.29032b90.js"><link rel="prefetch" href="/assets/js/6.3374be4e.js"><link rel="prefetch" href="/assets/js/7.8d4d8ec7.js"><link rel="prefetch" href="/assets/js/8.d15a2d70.js"><link rel="prefetch" href="/assets/js/9.4b953eaf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2749efcc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">YSW-NOTE</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Java笔记</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java/SpringBoot.html" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/Java/MybatisPlus.html" class="nav-link">MybatisPlus</a></li><li class="dropdown-item"><!----> <a href="/Java/Java基础.html" class="nav-link">Java基础</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Docker笔记</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Docker/docker命令.html" class="nav-link">docker命令</a></li><li class="dropdown-item"><!----> <a href="/Docker/软件安装.html" class="nav-link">软件安装</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端笔记</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Web/Html标签.html" class="nav-link">Html标签</a></li><li class="dropdown-item"><!----> <a href="/Web/CSS3属性.html" class="nav-link">CSS3属性</a></li><li class="dropdown-item"><!----> <a href="/Web/Vue.html" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Something</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Other/12306.html" class="nav-link">12306</a></li><li class="dropdown-item"><!----> <a href="/Other/CentOS 7.html" class="nav-link">CentOS 7</a></li><li class="dropdown-item"><!----> <a href="/Other/Git.html" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/Other/sfow项目部署.html" class="nav-link">SFOW</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Java笔记</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java/SpringBoot.html" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/Java/MybatisPlus.html" class="nav-link">MybatisPlus</a></li><li class="dropdown-item"><!----> <a href="/Java/Java基础.html" class="nav-link">Java基础</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Docker笔记</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Docker/docker命令.html" class="nav-link">docker命令</a></li><li class="dropdown-item"><!----> <a href="/Docker/软件安装.html" class="nav-link">软件安装</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端笔记</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Web/Html标签.html" class="nav-link">Html标签</a></li><li class="dropdown-item"><!----> <a href="/Web/CSS3属性.html" class="nav-link">CSS3属性</a></li><li class="dropdown-item"><!----> <a href="/Web/Vue.html" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Something</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Other/12306.html" class="nav-link">12306</a></li><li class="dropdown-item"><!----> <a href="/Other/CentOS 7.html" class="nav-link">CentOS 7</a></li><li class="dropdown-item"><!----> <a href="/Other/Git.html" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/Other/sfow项目部署.html" class="nav-link">SFOW</a></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>[TOC]</p> <h3 id="_1-stack（栈）"><a href="#_1-stack（栈）" aria-hidden="true" class="header-anchor">#</a> 1. Stack（栈）</h3> <p><img src="https://image.fundebug.com/2019-08-12-stack.png" alt="img"></p> <p>Stack的特点是后进先出（last in first out）。生活中常见的Stack的例子比如一摞书，你最后放上去的那本你之后会最先拿走；又比如浏览器的访问历史，当点击返回按钮，最后访问的网站最先从历史记录中弹出。</p> <p>Stack一般具备以下方法：</p> <ol><li><code>push</code>：将一个元素推入栈顶</li> <li><code>pop</code>：移除栈顶元素，并返回被移除的元素</li> <li><code>peek</code>：返回栈顶元素</li> <li><code>length</code>：返回栈中元素的个数</li></ol> <p>Javascript的Array天生具备了Stack的特性，但我们也可以从头实现一个 Stack类：</p> <div class="language- extra-class"><pre class="language-text"><code>function Stack() {
  this.count = 0;
  this.storage = {};

  this.push = function (value) {
    this.storage[this.count] = value;
    this.count++;
  }

  this.pop = function () {
    if (this.count === 0) {
      return undefined;
    }
    this.count--;
    var result = this.storage[this.count];
    delete this.storage[this.count];
    return result;
  }

  this.peek = function () {
    return this.storage[this.count - 1];
  }

  this.size = function () {
    return this.count;
  }
}
</code></pre></div><h3 id="_2-queue（队列）"><a href="#_2-queue（队列）" aria-hidden="true" class="header-anchor">#</a> 2. Queue（队列）</h3> <p><img src="https://image.fundebug.com/2019-08-12-queue.png" alt="img"></p> <p>Queue和Stack有一些类似，不同的是Stack是先进后出，而Queue是先进先出。Queue在生活中的例子比如排队上公交，排在第一个的总是最先上车；又比如打印机的打印队列，排在前面的最先打印。</p> <p>Queue一般具有以下常见方法：</p> <ol><li><code>enqueue</code>：入列，向队列尾部增加一个元素</li> <li><code>dequeue</code>：出列，移除队列头部的一个元素并返回被移除的元素</li> <li><code>front</code>：获取队列的第一个元素</li> <li><code>isEmpty</code>：判断队列是否为空</li> <li><code>size</code>：获取队列中元素的个数</li></ol> <p>Javascript中的Array已经具备了Queue的一些特性，所以我们可以借助Array实现一个Queue类型：</p> <div class="language- extra-class"><pre class="language-text"><code>function Queue() {
  var collection = [];

  this.print = function () {
    console.log(collection);
  }

  this.enqueue = function (element) {
    collection.push(element);
  }

  this.dequeue = function () {
    return collection.shift();
  }

  this.front = function () {
    return collection[0];
  }

  this.isEmpty = function () {
    return collection.length === 0;
  }

  this.size = function () {
    return collection.length;
  }
}
</code></pre></div><h4 id="priority-queue（优先队列）"><a href="#priority-queue（优先队列）" aria-hidden="true" class="header-anchor">#</a> Priority Queue（优先队列）</h4> <p>Queue还有个升级版本，给每个元素赋予优先级，优先级高的元素入列时将排到低优先级元素之前。区别主要是<code>enqueue</code>方法的实现：</p> <div class="language- extra-class"><pre class="language-text"><code>function PriorityQueue() {

  ...

  this.enqueue = function (element) {
    if (this.isEmpty()) {
      collection.push(element);
    } else {
      var added = false;
      for (var i = 0; i &lt; collection.length; i++) {
        if (element[1] &lt; collection[i][1]) {
          collection.splice(i, 0, element);
          added = true;
          break;
        }
      }
      if (!added) {
        collection.push(element);
      }
    }
  }
}
</code></pre></div><p><strong>测试一下：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var pQ = new PriorityQueue();

pQ.enqueue(['gannicus', 3]);
pQ.enqueue(['spartacus', 1]);
pQ.enqueue(['crixus', 2]);
pQ.enqueue(['oenomaus', 4]);

pQ.print();
</code></pre></div><p><strong>结果：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>[
  [ 'spartacus', 1 ],
  [ 'crixus', 2 ],
  [ 'gannicus', 3 ],
  [ 'oenomaus', 4 ]
]
</code></pre></div><h3 id="_3-linked-list（链表）"><a href="#_3-linked-list（链表）" aria-hidden="true" class="header-anchor">#</a> 3. Linked List（链表）</h3> <p><img src="https://image.fundebug.com/2019-08-12-linked-list.png" alt="img"></p> <p>顾名思义，链表是一种链式数据结构，链上的每个节点包含两种信息：节点本身的数据和指向下一个节点的指针。链表和传统的数组都是线性的数据结构，存储的都是一个序列的数据，但也有很多区别，如下表：</p> <table><thead><tr><th>比较维度</th> <th>数组</th> <th>链表</th></tr></thead> <tbody><tr><td>内存分配</td> <td>静态内存分配，编译时分配且连续</td> <td>动态内存分配，运行时分配且不连续</td></tr> <tr><td>元素获取</td> <td>通过Index获取，速度较快</td> <td>通过遍历顺序访问，速度较慢</td></tr> <tr><td>添加删除元素</td> <td>因为内存位置连续且固定，速度较慢</td> <td>因为内存分配灵活，只有一个开销步骤，速度更快</td></tr> <tr><td>空间结构</td> <td>可以是一维或者多维数组</td> <td>可以是单向、双向或者循环链表</td></tr></tbody></table> <p>一个单向链表通常具有以下方法：</p> <ol><li><code>size</code>：返回链表中节点的个数</li> <li><code>head</code>：返回链表中的头部元素</li> <li><code>add</code>：向链表尾部增加一个节点</li> <li><code>remove</code>：删除某个节点</li> <li><code>indexOf</code>：返回某个节点的index</li> <li><code>elementAt</code>：返回某个index处的节点</li> <li><code>addAt</code>：在某个index处插入一个节点</li> <li><code>removeAt</code>：删除某个index处的节点</li></ol> <p><strong>单向链表的Javascript实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>/**
 * 链表中的节点 
 */
function Node(element) {
  // 节点中的数据
  this.element = element;
  // 指向下一个节点的指针
  this.next = null;
}

function LinkedList() {
  var length = 0;
  var head = null;

  this.size = function () {
    return length;
  }

  this.head = function () {
    return head;
  }

  this.add = function (element) {
    var node = new Node(element);
    if (head == null) {
      head = node;
    } else {
      var currentNode = head;

      while (currentNode.next) {
        currentNode = currentNode.next;
      }

      currentNode.next = node;
    }
    length++;
  }

  this.remove = function (element) {
    var currentNode = head;
    var previousNode;
    if (currentNode.element === element) {
      head = currentNode.next;
    } else {
      while (currentNode.element !== element) {
        previousNode = currentNode;
        currentNode = currentNode.next;
      }
      previousNode.next = currentNode.next;
    }
    length--;
  }

  this.isEmpty = function () {
    return length === 0;
  }

  this.indexOf = function (element) {
    var currentNode = head;
    var index = -1;
    while (currentNode) {
      index++;
      if (currentNode.element === element) {
        return index;
      }
      currentNode = currentNode.next;
    }

    return -1;
  }

  this.elementAt = function (index) {
    var currentNode = head;
    var count = 0;
    while (count &lt; index) {
      count++;
      currentNode = currentNode.next;
    }
    return currentNode.element;
  }

  this.addAt = function (index, element) {
    var node = new Node(element);
    var currentNode = head;
    var previousNode;
    var currentIndex = 0;

    if (index &gt; length) {
      return false;
    }

    if (index === 0) {
      node.next = currentNode;
      head = node;
    } else {
      while (currentIndex &lt; index) {
        currentIndex++;
        previousNode = currentNode;
        currentNode = currentNode.next;
      }
      node.next = currentNode;
      previousNode.next = node;
    }
    length++;
  }

  this.removeAt = function (index) {
    var currentNode = head;
    var previousNode;
    var currentIndex = 0;
    if (index &lt; 0 || index &gt;= length) {
      return null;
    }
    if (index === 0) {
      head = currentIndex.next;
    } else {
      while (currentIndex &lt; index) {
        currentIndex++;
        previousNode = currentNode;
        currentNode = currentNode.next;
      }
      previousNode.next = currentNode.next;
    }
    length--;
    return currentNode.element;
  }
}
</code></pre></div><h3 id="_4-set（集合）"><a href="#_4-set（集合）" aria-hidden="true" class="header-anchor">#</a> 4. Set（集合）</h3> <p><img src="https://image.fundebug.com/2019-08-12-set.png" alt="img"></p> <p>集合是数学中的一个基本概念，表示具有某种特性的对象汇总成的集体。在ES6中也引入了集合类型Set，Set和Array有一定程度的相似，不同的是Set中不允许出现重复的元素而且是无序的。</p> <p>一个典型的Set应该具有以下方法：</p> <ol><li><code>values</code>：返回集合中的所有元素</li> <li><code>size</code>：返回集合中元素的个数</li> <li><code>has</code>：判断集合中是否存在某个元素</li> <li><code>add</code>：向集合中添加元素</li> <li><code>remove</code>：从集合中移除某个元素</li> <li><code>union</code>：返回两个集合的并集</li> <li><code>intersection</code>：返回两个集合的交集</li> <li><code>difference</code>：返回两个集合的差集</li> <li><code>subset</code>：判断一个集合是否为另一个集合的子集</li></ol> <p>使用Javascript可以将Set进行如下实现，为了区别于ES6中的Set命名为MySet：</p> <div class="language- extra-class"><pre class="language-text"><code>function MySet() {
  var collection = [];
  this.has = function (element) {
    return (collection.indexOf(element) !== -1);
  }

  this.values = function () {
    return collection;
  }

  this.size = function () {
    return collection.length;
  }

  this.add = function (element) {
    if (!this.has(element)) {
      collection.push(element);
      return true;
    }
    return false;
  }

  this.remove = function (element) {
    if (this.has(element)) {
      index = collection.indexOf(element);
      collection.splice(index, 1);
      return true;
    }
    return false;
  }

  this.union = function (otherSet) {
    var unionSet = new MySet();
    var firstSet = this.values();
    var secondSet = otherSet.values();
    firstSet.forEach(function (e) {
      unionSet.add(e);
    });
    secondSet.forEach(function (e) {
      unionSet.add(e);
    });
    return unionSet;
  }

  this.intersection = function (otherSet) {
    var intersectionSet = new MySet();
    var firstSet = this.values();
    firstSet.forEach(function (e) {
      if (otherSet.has(e)) {
        intersectionSet.add(e);
      }
    });
    return intersectionSet;
  }

  this.difference = function (otherSet) {
    var differenceSet = new MySet();
    var firstSet = this.values();
    firstSet.forEach(function (e) {
      if (!otherSet.has(e)) {
        differenceSet.add(e);
      }
    });
    return differenceSet;
  }

  this.subset = function (otherSet) {
    var firstSet = this.values();
    return firstSet.every(function (value) {
      return otherSet.has(value);
    });
  }
}
</code></pre></div><blockquote><p>最后，推荐大家使用<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.fundebug.com%2F%3Futm_source%3DMudOnTire" target="_blank" rel="noopener noreferrer">Fundebug<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，一款很好用的BUG监控工具~</p></blockquote> <h3 id="_5-hash-table（哈希表-散列表）"><a href="#_5-hash-table（哈希表-散列表）" aria-hidden="true" class="header-anchor">#</a> 5. Hash Table（哈希表/散列表）</h3> <p><img src="https://image.fundebug.com/2019-08-12-hash%20table.png" alt="img"></p> <p>Hash Table是一种用于存储键值对（key value pair）的数据结构，因为Hash  Table根据key查询value的速度很快，所以它常用于实现Map、Dictinary、Object等数据结构。如上图所示，Hash  Table内部使用一个hash函数将传入的键转换成一串数字，而这串数字将作为键值对实际的key，通过这个key查询对应的value非常快，时间复杂度将达到O(1)。Hash函数要求相同输入对应的输出必须相等，而不同输入对应的输出必须不等，相当于对每对数据打上唯一的指纹。</p> <p>一个Hash Table通常具有下列方法：</p> <ol><li><code>add</code>：增加一组键值对</li> <li><code>remove</code>：删除一组键值对</li> <li><code>lookup</code>：查找一个键对应的值</li></ol> <p><strong>一个简易版本的Hash Table的Javascript实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function hash(string, max) {
  var hash = 0;
  for (var i = 0; i &lt; string.length; i++) {
    hash += string.charCodeAt(i);
  }
  return hash % max;
}

function HashTable() {
  let storage = [];
  const storageLimit = 4;

  this.add = function (key, value) {
    var index = hash(key, storageLimit);
    if (storage[index] === undefined) {
      storage[index] = [
        [key, value]
      ];
    } else {
      var inserted = false;
      for (var i = 0; i &lt; storage[index].length; i++) {
        if (storage[index][i][0] === key) {
          storage[index][i][1] = value;
          inserted = true;
        }
      }
      if (inserted === false) {
        storage[index].push([key, value]);
      }
    }
  }

  this.remove = function (key) {
    var index = hash(key, storageLimit);
    if (storage[index].length === 1 &amp;&amp; storage[index][0][0] === key) {
      delete storage[index];
    } else {
      for (var i = 0; i &lt; storage[index]; i++) {
        if (storage[index][i][0] === key) {
          delete storage[index][i];
        }
      }
    }
  }

  this.lookup = function (key) {
    var index = hash(key, storageLimit);
    if (storage[index] === undefined) {
      return undefined;
    } else {
      for (var i = 0; i &lt; storage[index].length; i++) {
        if (storage[index][i][0] === key) {
          return storage[index][i][1];
        }
      }
    }
  }
}
</code></pre></div><h3 id="_6-tree（树）"><a href="#_6-tree（树）" aria-hidden="true" class="header-anchor">#</a> 6. Tree（树）</h3> <p><img src="https://image.fundebug.com/2019-08-12-tree.png" alt="img"></p> <p>顾名思义，Tree的数据结构和自然界中的树极其相似，有根、树枝、叶子，如上图所示。Tree是一种多层数据结构，与Array、Stack、Queue相比是一种非线性的数据结构，在进行插入和搜索操作时很高效。在描述一个Tree时经常会用到下列概念：</p> <ol><li>Root（根）：代表树的根节点，根节点没有父节点</li> <li>Parent Node（父节点）：一个节点的直接上级节点，只有一个</li> <li>Child Node（子节点）：一个节点的直接下级节点，可能有多个</li> <li>Siblings（兄弟节点）：具有相同父节点的节点</li> <li>Leaf（叶节点）：没有子节点的节点</li> <li>Edge（边）：两个节点之间的连接线</li> <li>Path（路径）：从源节点到目标节点的连续边</li> <li>Height of Node（节点的高度）：表示节点与叶节点之间的最长路径上边的个数</li> <li>Height of Tree（树的高度）：即根节点的高度</li> <li>Depth of Node（节点的深度）：表示从根节点到该节点的边的个数</li> <li>Degree of Node（节点的度）：表示子节点的个数</li></ol> <p>我们以二叉查找树为例，展示树在Javascript中的实现。在二叉查找树中，即每个节点最多只有两个子节点，而左侧子节点小于当前节点，而右侧子节点大于当前节点，如图所示：</p> <p><img src="https://image.fundebug.com/2019-08-12-BST.png" alt="img"></p> <p>一个二叉查找树应该具有以下常用方法：</p> <ol><li><code>add</code>：向树中插入一个节点</li> <li><code>findMin</code>：查找树中最小的节点</li> <li><code>findMax</code>：查找树中最大的节点</li> <li><code>find</code>：查找树中的某个节点</li> <li><code>isPresent</code>：判断某个节点在树中是否存在</li> <li><code>remove</code>：移除树中的某个节点</li></ol> <p>以下是二叉查找树的Javascript实现：</p> <div class="language- extra-class"><pre class="language-text"><code>class Node {
  constructor(data, left = null, right = null) {
    this.data = data;
    this.left = left;
    this.right = right;
  }
}

class BST {
  constructor() {
    this.root = null;
  }

  add(data) {
    const node = this.root;
    if (node === null) {
      this.root = new Node(data);
      return;
    } else {
      const searchTree = function (node) {
        if (data &lt; node.data) {
          if (node.left === null) {
            node.left = new Node(data);
            return;
          } else if (node.left !== null) {
            return searchTree(node.left);
          }
        } else if (data &gt; node.data) {
          if (node.right === null) {
            node.right = new Node(data);
            return;
          } else if (node.right !== null) {
            return searchTree(node.right);
          }
        } else {
          return null;
        }
      };
      return searchTree(node);
    }
  }

  findMin() {
    let current = this.root;
    while (current.left !== null) {
      current = current.left;
    }
    return current.data;
  }

  findMax() {
    let current = this.root;
    while (current.right !== null) {
      current = current.right;
    }
    return current.data;
  }

  find(data) {
    let current = this.root;
    while (current.data !== data) {
      if (data &lt; current.data) {
        current = current.left
      } else {
        current = current.right;
      }
      if (current === null) {
        return null;
      }
    }
    return current;
  }

  isPresent(data) {
    let current = this.root;
    while (current) {
      if (data === current.data) {
        return true;
      }
      if (data &lt; current.data) {
        current = current.left;
      } else {
        current = current.right;
      }
    }
    return false;
  }

  remove(data) {
    const removeNode = function (node, data) {
      if (node == null) {
        return null;
      }
      if (data == node.data) {
        // node没有子节点
        if (node.left == null &amp;&amp; node.right == null) {
          return null;
        }
        // node没有左侧子节点
        if (node.left == null) {
          return node.right;
        }
        // node没有右侧子节点
        if (node.right == null) {
          return node.left;
        }
        // node有两个子节点
        var tempNode = node.right;
        while (tempNode.left !== null) {
          tempNode = tempNode.left;
        }
        node.data = tempNode.data;
        node.right = removeNode(node.right, tempNode.data);
        return node;
      } else if (data &lt; node.data) {
        node.left = removeNode(node.left, data);
        return node;
      } else {
        node.right = removeNode(node.right, data);
        return node;
      }
    }
    this.root = removeNode(this.root, data);
  }
}
</code></pre></div><p><strong>测试一下：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const bst = new BST();

bst.add(4);
bst.add(2);
bst.add(6);
bst.add(1);
bst.add(3);
bst.add(5);
bst.add(7);
bst.remove(4);
console.log(bst.findMin());
console.log(bst.findMax());
bst.remove(7);
console.log(bst.findMax());
console.log(bst.isPresent(4));
</code></pre></div><p><strong>打印结果：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>1
7
6
false
</code></pre></div><h3 id="_7-trie（字典树，读音同try）"><a href="#_7-trie（字典树，读音同try）" aria-hidden="true" class="header-anchor">#</a> 7. Trie（字典树，读音同try）</h3> <p><img src="https://image.fundebug.com/2019-08-12-trie.png" alt="img"></p> <p>Trie也可以叫做Prefix  Tree（前缀树），也是一种搜索树。Trie分步骤存储数据，树中的每个节点代表一个步骤，trie常用于存储单词以便快速查找，比如实现单词的自动完成功能。   Trie中的每个节点都包含一个单词的字母，跟着树的分支可以可以拼写出一个完整的单词，每个节点还包含一个布尔值表示该节点是否是单词的最后一个字母。</p> <p>Trie一般有以下方法：</p> <ol><li><code>add</code>：向字典树中增加一个单词</li> <li><code>isWord</code>：判断字典树中是否包含某个单词</li> <li><code>print</code>：返回字典树中的所有单词</li></ol> <div class="language- extra-class"><pre class="language-text"><code>/**
 * Trie的节点
 */
function Node() {
  this.keys = new Map();
  this.end = false;
  this.setEnd = function () {
    this.end = true;
  };
  this.isEnd = function () {
    return this.end;
  }
}

function Trie() {
  this.root = new Node();

  this.add = function (input, node = this.root) {
    if (input.length === 0) {
      node.setEnd();
      return;
    } else if (!node.keys.has(input[0])) {
      node.keys.set(input[0], new Node());
      return this.add(input.substr(1), node.keys.get(input[0]));
    } else {
      return this.add(input.substr(1), node.keys.get(input[0]));
    }
  }

  this.isWord = function (word) {
    let node = this.root;
    while (word.length &gt; 1) {
      if (!node.keys.has(word[0])) {
        return false;
      } else {
        node = node.keys.get(word[0]);
        word = word.substr(1);
      }
    }
    return (node.keys.has(word) &amp;&amp; node.keys.get(word).isEnd()) ? true : false;
  }

  this.print = function () {
    let words = new Array();
    let search = function (node = this.root, string) {
      if (node.keys.size != 0) {
        for (let letter of node.keys.keys()) {
          search(node.keys.get(letter), string.concat(letter));
        }
        if (node.isEnd()) {
          words.push(string);
        }
      } else {
        string.length &gt; 0 ? words.push(string) : undefined;
        return;
      }
    };
    search(this.root, new String());
    return words.length &gt; 0 ? words : null;
  }
}
</code></pre></div><h3 id="_8-graph（图）"><a href="#_8-graph（图）" aria-hidden="true" class="header-anchor">#</a> 8. Graph（图）</h3> <p><img src="https://image.fundebug.com/2019-08-12-graph.png" alt="img"></p> <p>Graph是节点（或顶点）以及它们之间的连接（或边）的集合。Graph也可以称为Network（网络）。根据节点之间的连接是否有方向又可以分为Directed  Graph（有向图）和Undrected  Graph（无向图）。Graph在实际生活中有很多用途，比如：导航软件计算最佳路径，社交软件进行好友推荐等等。</p> <p>Graph通常有两种表达方式：</p> <p><strong>Adjaceny List（邻接列表）</strong>：</p> <p><img src="https://image.fundebug.com/2019-08-12-adj-list.png" alt="img"></p> <p>邻接列表可以表示为左侧是节点的列表，右侧列出它所连接的所有其他节点。</p> <p>和 <strong>Adjacency Matrix（邻接矩阵）</strong>：</p> <p><img src="https://image.fundebug.com/2019-08-12-adj-matrix.png" alt="img"></p> <p>邻接矩阵用矩阵来表示节点之间的连接关系，每行或者每列表示一个节点，行和列的交叉处的数字表示节点之间的关系：0表示没用连接，1表示有连接，大于1表示不同的权重。</p> <p>访问Graph中的节点需要使用遍历算法，遍历算法又分为广度优先和深度优先，主要用于确定目标节点和根节点之间的距离，</p> <p>在Javascript中，Graph可以用一个矩阵（二维数组）表示，广度优先搜索算法可以实现如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function bfs(graph, root) {
  var nodesLen = {};

  for (var i = 0; i &lt; graph.length; i++) {
    nodesLen[i] = Infinity;
  }

  nodesLen[root] = 0;

  var queue = [root];
  var current;

  while (queue.length != 0) {
    current = queue.shift();

    var curConnected = graph[current];
    var neighborIdx = [];
    var idx = curConnected.indexOf(1);
    while (idx != -1) {
      neighborIdx.push(idx);
      idx = curConnected.indexOf(1, idx + 1);
    }

    for (var j = 0; j &lt; neighborIdx.length; j++) {
      if (nodesLen[neighborIdx[j]] == Infinity) {
        nodesLen[neighborIdx[j]] = nodesLen[current] + 1;
        queue.push(neighborIdx[j]);
      }
    }
  }

  return nodesLen;
}
</code></pre></div><p><strong>测试一下：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var graph = [
  [0, 1, 1, 1, 0],
  [0, 0, 1, 0, 0],
  [1, 1, 0, 0, 0],
  [0, 0, 0, 1, 0],
  [0, 1, 0, 0, 0]
];

console.log(bfs(graph, 1));
</code></pre></div><p><strong>打印：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>{
  0: 2,
  1: 0,
  2: 1,
  3: 3,
  4: Infinity
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2d4845b5.js" defer></script><script src="/assets/js/2.974af1fb.js" defer></script><script src="/assets/js/11.652fa16d.js" defer></script>
  </body>
</html>
