[TOC]

# JavaScript 语法及问题记录

## 一、JavaScript内置对象

### 1、`Object对象`

> 

方法列表

### 2、`String 对象`

> 



### 3、`Array对象`

> - 构造函数
>
>     ```
>     new Array();
>     new Array(size);
>     new Array(element0, element1, ..., elementn);
>     ```
>
>     - 参数 `size` 是期望的数组元素个数。返回的数组，length 字段将被设为 `size `的值。
>    
>     - 参数 *element* ..., *elementn* 是参数列表。当使用这些参数来调用构造函数 Array() 时，新创建的数组的元素就会被初始化为这些值。它的 length 字段也会被设置为参数的个数。
>    
>     - 返回新创建并被初始化了的数组。
>    
>         - 如果调用构造函数 Array() 时没有使用参数，那么返回的数组为空，length 字段为 0。
>    
>         - 当调用构造函数时只传递给它一个数字参数，该构造函数将返回具有指定个数、元素为 undefined 的数组。
>    
>         - 当其他参数调用 Array() 时，该构造函数将用参数指定的值初始化数组。
>    
>         - 当把构造函数作为函数调用，不使用 new 运算符时，它的行为与使用 new 运算符调用它时的行为完全一样。

#### 1、`constructor `

> 返回对创建此对象的数组函数的引用。

#### 2、`length  `

> 设置或返回数组中元素的数目。

#### 3、`prototype`

> 使您有能力向对象添加属性和方法。



#### 4、`concat()  `      

> 连接两个或更多的数组，并返回结果。



#### 5、`join()  `

> 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。



#### 6、`pop()   `

> 删除并返回数组的最后一个元素



#### 7、`push()  `

> 向数组的末尾添加一个或更多元素，并返回新的长度。



#### 8、`reverse()` 

> 颠倒数组中元素的顺序。



#### 9、`shift()` 

> 删除并返回数组的第一个元素



#### 10、`slice() `

> 从某个已有的数组返回选定的元素



#### 11、`sort() `

> 对数组的元素进行排序



#### 12、`splice()`

> 删除元素，并向数组添加新元素。



#### 13、`toSource()  `    

> 返回该对象的源代码。



#### 14、`toString()`

> 把数组转换为字符串，并返回结果。



#### 15、`toLocaleString()`  

> 把数组转换为本地数组，并返回结果。



#### 16、`unshift()`

> 向数组的开头添加一个或更多元素，并返回新的长度。



#### 17、`valueOf()`

> 返回数组对象的原始值

### 4、Math对象

- Math.PI：圆周率。
- Math.abs()：绝对值。如：Math.abs(-9) = 9
- Math.ceil()：向上取整(整数加1，小数去掉)。如：Math.ceil(10.2) = 11
- Math.floor()：向下取整(直接去掉小数)。如：Math.floor(9.888) = 9
- Math.round()：四舍五入。如：Math.round(4.5) = 5; Math.round(4.1) = 4
- Math.pow(x,y)：求x的y次方。如：Math.pow(2,3) = 8
- Math.sqrt()：求平方根。如：Math.sqrt(121) = 11

### 5、Date对象

### 6、Event对象

### 7、Number对象	

### 8、Boolean对象











## 二、专业名词

### 1、闭包

> 释义：`闭包`是有权访问另一个函数作用域的变量的`函数`。
>
> 简单的说，Javascript允许使用内部函数---即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。
>
> - `闭包的作用`：
>
>     - 可以读取函数内部的变量
>     - 让某些局部变量的值始终保持在内存中
>
> - `使用闭包的注意点`
>
>     - 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
>     - 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
>
> - `闭包与this对象`
>
>     - 在闭包中使用this对象可能会导致一些问题，因为匿名函数的执行具有全局性，因此其this对象通常指window
>     - 把外部作用域的this对象保存在一个闭包能够访问的变量里面，就可以让闭包访问对象了，
>
> - **闭包示例**
>
>     ```javascript
>     function test(){
>     	var n = 1;
>     	return function(){
>     		console.log(n);
>     	}
>     }
>     var result = test();
>     result(); //1
>     ```
>
>     
>
>     

#### 1、作用域链

> - 简单来说，作用域链就是函数在定义的时候创建的，用于寻找使用到的变量的值的一个索引，
> - 作用域链内部的规则是，把函数自身的本地变量放在最前面，把自身的父级函数中的变量放在其次，把再高一级函数中的变量放在更后面，以此类推直至全局对象为止。
> - 当函数中需要查询一个变量的值的时候，js解释器会去作用域链去查找，从最前面的本地变量中先找，如果没有找到对应的变量，则到下一级的链上找，一旦找到了变量，则不再继续。如果找到最后也没找到需要的变量，则解释器返回undefined.

#### 2、js的内存回收机制

> - 一个函数在执行开始的时候，会给其中定义的变量划分内存空间保存，以备后面的语句所用，等到函数执行完毕返回了，这些变量就被认为是无用的了，对应的内存空间也就被回收了，下次再执行此函数的时候，所有的变量又回到最初的状态，重新赋值使用。
>
> - 如果一个函数内部又嵌套了另一个函数，而这个函数是有可能在外部被调用到的。并且这个内部函数又使用了外部函数的某些变量的话，这种内存回收机制就会出现问题。如果在外部函数返回后，又直接调用了内部函数，那么内部函数就无法读取到他所需要的外部函数中变量的值了。所以js解释器在遇到函数定义的时候，会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包，这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了，或者没有了指针)，才会销毁这个闭包，而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收。
>
> - **闭包使用示例**
>
>     ```
>     //方案二
>     var oList = document.getElementsByTagName('li');
>     function makeHelpCallback(i){
>         return function(){
>             console.log(i);
>         }
>     }
>     for(var i=0;i<oList.length;i++){
>         oList[i].onclick = makeHelpCallback(i);
>     }
>     
>     //方案二
>     var oList = document.getElementsByTagName('li');
>     for (var i = 0; i < oList.length; i++) {
>        (function (index) {  //index相当于形参
>             oList[index].onclick = function () {
>                 console.log(index);
>             }
>         })(i) //i相当于实参
>     }
>     ```
>
>     



























