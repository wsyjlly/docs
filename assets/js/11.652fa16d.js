(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{209:function(n,e,t){"use strict";t.r(e);var r=t(0),i=Object(r.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("[TOC]")]),n._v(" "),t("h3",{attrs:{id:"_1-stack（栈）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-stack（栈）","aria-hidden":"true"}},[n._v("#")]),n._v(" 1. Stack（栈）")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-stack.png",alt:"img"}})]),n._v(" "),t("p",[n._v("Stack的特点是后进先出（last in first out）。生活中常见的Stack的例子比如一摞书，你最后放上去的那本你之后会最先拿走；又比如浏览器的访问历史，当点击返回按钮，最后访问的网站最先从历史记录中弹出。")]),n._v(" "),t("p",[n._v("Stack一般具备以下方法：")]),n._v(" "),t("ol",[t("li",[t("code",[n._v("push")]),n._v("：将一个元素推入栈顶")]),n._v(" "),t("li",[t("code",[n._v("pop")]),n._v("：移除栈顶元素，并返回被移除的元素")]),n._v(" "),t("li",[t("code",[n._v("peek")]),n._v("：返回栈顶元素")]),n._v(" "),t("li",[t("code",[n._v("length")]),n._v("：返回栈中元素的个数")])]),n._v(" "),t("p",[n._v("Javascript的Array天生具备了Stack的特性，但我们也可以从头实现一个 Stack类：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function Stack() {\n  this.count = 0;\n  this.storage = {};\n\n  this.push = function (value) {\n    this.storage[this.count] = value;\n    this.count++;\n  }\n\n  this.pop = function () {\n    if (this.count === 0) {\n      return undefined;\n    }\n    this.count--;\n    var result = this.storage[this.count];\n    delete this.storage[this.count];\n    return result;\n  }\n\n  this.peek = function () {\n    return this.storage[this.count - 1];\n  }\n\n  this.size = function () {\n    return this.count;\n  }\n}\n")])])]),t("h3",{attrs:{id:"_2-queue（队列）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-queue（队列）","aria-hidden":"true"}},[n._v("#")]),n._v(" 2. Queue（队列）")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-queue.png",alt:"img"}})]),n._v(" "),t("p",[n._v("Queue和Stack有一些类似，不同的是Stack是先进后出，而Queue是先进先出。Queue在生活中的例子比如排队上公交，排在第一个的总是最先上车；又比如打印机的打印队列，排在前面的最先打印。")]),n._v(" "),t("p",[n._v("Queue一般具有以下常见方法：")]),n._v(" "),t("ol",[t("li",[t("code",[n._v("enqueue")]),n._v("：入列，向队列尾部增加一个元素")]),n._v(" "),t("li",[t("code",[n._v("dequeue")]),n._v("：出列，移除队列头部的一个元素并返回被移除的元素")]),n._v(" "),t("li",[t("code",[n._v("front")]),n._v("：获取队列的第一个元素")]),n._v(" "),t("li",[t("code",[n._v("isEmpty")]),n._v("：判断队列是否为空")]),n._v(" "),t("li",[t("code",[n._v("size")]),n._v("：获取队列中元素的个数")])]),n._v(" "),t("p",[n._v("Javascript中的Array已经具备了Queue的一些特性，所以我们可以借助Array实现一个Queue类型：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function Queue() {\n  var collection = [];\n\n  this.print = function () {\n    console.log(collection);\n  }\n\n  this.enqueue = function (element) {\n    collection.push(element);\n  }\n\n  this.dequeue = function () {\n    return collection.shift();\n  }\n\n  this.front = function () {\n    return collection[0];\n  }\n\n  this.isEmpty = function () {\n    return collection.length === 0;\n  }\n\n  this.size = function () {\n    return collection.length;\n  }\n}\n")])])]),t("h4",{attrs:{id:"priority-queue（优先队列）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#priority-queue（优先队列）","aria-hidden":"true"}},[n._v("#")]),n._v(" Priority Queue（优先队列）")]),n._v(" "),t("p",[n._v("Queue还有个升级版本，给每个元素赋予优先级，优先级高的元素入列时将排到低优先级元素之前。区别主要是"),t("code",[n._v("enqueue")]),n._v("方法的实现：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function PriorityQueue() {\n\n  ...\n\n  this.enqueue = function (element) {\n    if (this.isEmpty()) {\n      collection.push(element);\n    } else {\n      var added = false;\n      for (var i = 0; i < collection.length; i++) {\n        if (element[1] < collection[i][1]) {\n          collection.splice(i, 0, element);\n          added = true;\n          break;\n        }\n      }\n      if (!added) {\n        collection.push(element);\n      }\n    }\n  }\n}\n")])])]),t("p",[t("strong",[n._v("测试一下：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var pQ = new PriorityQueue();\n\npQ.enqueue(['gannicus', 3]);\npQ.enqueue(['spartacus', 1]);\npQ.enqueue(['crixus', 2]);\npQ.enqueue(['oenomaus', 4]);\n\npQ.print();\n")])])]),t("p",[t("strong",[n._v("结果：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("[\n  [ 'spartacus', 1 ],\n  [ 'crixus', 2 ],\n  [ 'gannicus', 3 ],\n  [ 'oenomaus', 4 ]\n]\n")])])]),t("h3",{attrs:{id:"_3-linked-list（链表）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-linked-list（链表）","aria-hidden":"true"}},[n._v("#")]),n._v(" 3. Linked List（链表）")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-linked-list.png",alt:"img"}})]),n._v(" "),t("p",[n._v("顾名思义，链表是一种链式数据结构，链上的每个节点包含两种信息：节点本身的数据和指向下一个节点的指针。链表和传统的数组都是线性的数据结构，存储的都是一个序列的数据，但也有很多区别，如下表：")]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",[n._v("比较维度")]),n._v(" "),t("th",[n._v("数组")]),n._v(" "),t("th",[n._v("链表")])])]),n._v(" "),t("tbody",[t("tr",[t("td",[n._v("内存分配")]),n._v(" "),t("td",[n._v("静态内存分配，编译时分配且连续")]),n._v(" "),t("td",[n._v("动态内存分配，运行时分配且不连续")])]),n._v(" "),t("tr",[t("td",[n._v("元素获取")]),n._v(" "),t("td",[n._v("通过Index获取，速度较快")]),n._v(" "),t("td",[n._v("通过遍历顺序访问，速度较慢")])]),n._v(" "),t("tr",[t("td",[n._v("添加删除元素")]),n._v(" "),t("td",[n._v("因为内存位置连续且固定，速度较慢")]),n._v(" "),t("td",[n._v("因为内存分配灵活，只有一个开销步骤，速度更快")])]),n._v(" "),t("tr",[t("td",[n._v("空间结构")]),n._v(" "),t("td",[n._v("可以是一维或者多维数组")]),n._v(" "),t("td",[n._v("可以是单向、双向或者循环链表")])])])]),n._v(" "),t("p",[n._v("一个单向链表通常具有以下方法：")]),n._v(" "),t("ol",[t("li",[t("code",[n._v("size")]),n._v("：返回链表中节点的个数")]),n._v(" "),t("li",[t("code",[n._v("head")]),n._v("：返回链表中的头部元素")]),n._v(" "),t("li",[t("code",[n._v("add")]),n._v("：向链表尾部增加一个节点")]),n._v(" "),t("li",[t("code",[n._v("remove")]),n._v("：删除某个节点")]),n._v(" "),t("li",[t("code",[n._v("indexOf")]),n._v("：返回某个节点的index")]),n._v(" "),t("li",[t("code",[n._v("elementAt")]),n._v("：返回某个index处的节点")]),n._v(" "),t("li",[t("code",[n._v("addAt")]),n._v("：在某个index处插入一个节点")]),n._v(" "),t("li",[t("code",[n._v("removeAt")]),n._v("：删除某个index处的节点")])]),n._v(" "),t("p",[t("strong",[n._v("单向链表的Javascript实现：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 链表中的节点 \n */\nfunction Node(element) {\n  // 节点中的数据\n  this.element = element;\n  // 指向下一个节点的指针\n  this.next = null;\n}\n\nfunction LinkedList() {\n  var length = 0;\n  var head = null;\n\n  this.size = function () {\n    return length;\n  }\n\n  this.head = function () {\n    return head;\n  }\n\n  this.add = function (element) {\n    var node = new Node(element);\n    if (head == null) {\n      head = node;\n    } else {\n      var currentNode = head;\n\n      while (currentNode.next) {\n        currentNode = currentNode.next;\n      }\n\n      currentNode.next = node;\n    }\n    length++;\n  }\n\n  this.remove = function (element) {\n    var currentNode = head;\n    var previousNode;\n    if (currentNode.element === element) {\n      head = currentNode.next;\n    } else {\n      while (currentNode.element !== element) {\n        previousNode = currentNode;\n        currentNode = currentNode.next;\n      }\n      previousNode.next = currentNode.next;\n    }\n    length--;\n  }\n\n  this.isEmpty = function () {\n    return length === 0;\n  }\n\n  this.indexOf = function (element) {\n    var currentNode = head;\n    var index = -1;\n    while (currentNode) {\n      index++;\n      if (currentNode.element === element) {\n        return index;\n      }\n      currentNode = currentNode.next;\n    }\n\n    return -1;\n  }\n\n  this.elementAt = function (index) {\n    var currentNode = head;\n    var count = 0;\n    while (count < index) {\n      count++;\n      currentNode = currentNode.next;\n    }\n    return currentNode.element;\n  }\n\n  this.addAt = function (index, element) {\n    var node = new Node(element);\n    var currentNode = head;\n    var previousNode;\n    var currentIndex = 0;\n\n    if (index > length) {\n      return false;\n    }\n\n    if (index === 0) {\n      node.next = currentNode;\n      head = node;\n    } else {\n      while (currentIndex < index) {\n        currentIndex++;\n        previousNode = currentNode;\n        currentNode = currentNode.next;\n      }\n      node.next = currentNode;\n      previousNode.next = node;\n    }\n    length++;\n  }\n\n  this.removeAt = function (index) {\n    var currentNode = head;\n    var previousNode;\n    var currentIndex = 0;\n    if (index < 0 || index >= length) {\n      return null;\n    }\n    if (index === 0) {\n      head = currentIndex.next;\n    } else {\n      while (currentIndex < index) {\n        currentIndex++;\n        previousNode = currentNode;\n        currentNode = currentNode.next;\n      }\n      previousNode.next = currentNode.next;\n    }\n    length--;\n    return currentNode.element;\n  }\n}\n")])])]),t("h3",{attrs:{id:"_4-set（集合）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-set（集合）","aria-hidden":"true"}},[n._v("#")]),n._v(" 4. Set（集合）")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-set.png",alt:"img"}})]),n._v(" "),t("p",[n._v("集合是数学中的一个基本概念，表示具有某种特性的对象汇总成的集体。在ES6中也引入了集合类型Set，Set和Array有一定程度的相似，不同的是Set中不允许出现重复的元素而且是无序的。")]),n._v(" "),t("p",[n._v("一个典型的Set应该具有以下方法：")]),n._v(" "),t("ol",[t("li",[t("code",[n._v("values")]),n._v("：返回集合中的所有元素")]),n._v(" "),t("li",[t("code",[n._v("size")]),n._v("：返回集合中元素的个数")]),n._v(" "),t("li",[t("code",[n._v("has")]),n._v("：判断集合中是否存在某个元素")]),n._v(" "),t("li",[t("code",[n._v("add")]),n._v("：向集合中添加元素")]),n._v(" "),t("li",[t("code",[n._v("remove")]),n._v("：从集合中移除某个元素")]),n._v(" "),t("li",[t("code",[n._v("union")]),n._v("：返回两个集合的并集")]),n._v(" "),t("li",[t("code",[n._v("intersection")]),n._v("：返回两个集合的交集")]),n._v(" "),t("li",[t("code",[n._v("difference")]),n._v("：返回两个集合的差集")]),n._v(" "),t("li",[t("code",[n._v("subset")]),n._v("：判断一个集合是否为另一个集合的子集")])]),n._v(" "),t("p",[n._v("使用Javascript可以将Set进行如下实现，为了区别于ES6中的Set命名为MySet：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function MySet() {\n  var collection = [];\n  this.has = function (element) {\n    return (collection.indexOf(element) !== -1);\n  }\n\n  this.values = function () {\n    return collection;\n  }\n\n  this.size = function () {\n    return collection.length;\n  }\n\n  this.add = function (element) {\n    if (!this.has(element)) {\n      collection.push(element);\n      return true;\n    }\n    return false;\n  }\n\n  this.remove = function (element) {\n    if (this.has(element)) {\n      index = collection.indexOf(element);\n      collection.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  this.union = function (otherSet) {\n    var unionSet = new MySet();\n    var firstSet = this.values();\n    var secondSet = otherSet.values();\n    firstSet.forEach(function (e) {\n      unionSet.add(e);\n    });\n    secondSet.forEach(function (e) {\n      unionSet.add(e);\n    });\n    return unionSet;\n  }\n\n  this.intersection = function (otherSet) {\n    var intersectionSet = new MySet();\n    var firstSet = this.values();\n    firstSet.forEach(function (e) {\n      if (otherSet.has(e)) {\n        intersectionSet.add(e);\n      }\n    });\n    return intersectionSet;\n  }\n\n  this.difference = function (otherSet) {\n    var differenceSet = new MySet();\n    var firstSet = this.values();\n    firstSet.forEach(function (e) {\n      if (!otherSet.has(e)) {\n        differenceSet.add(e);\n      }\n    });\n    return differenceSet;\n  }\n\n  this.subset = function (otherSet) {\n    var firstSet = this.values();\n    return firstSet.every(function (value) {\n      return otherSet.has(value);\n    });\n  }\n}\n")])])]),t("blockquote",[t("p",[n._v("最后，推荐大家使用"),t("a",{attrs:{href:"https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.fundebug.com%2F%3Futm_source%3DMudOnTire",target:"_blank",rel:"noopener noreferrer"}},[n._v("Fundebug"),t("OutboundLink")],1),n._v("，一款很好用的BUG监控工具~")])]),n._v(" "),t("h3",{attrs:{id:"_5-hash-table（哈希表-散列表）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-hash-table（哈希表-散列表）","aria-hidden":"true"}},[n._v("#")]),n._v(" 5. Hash Table（哈希表/散列表）")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-hash%20table.png",alt:"img"}})]),n._v(" "),t("p",[n._v("Hash Table是一种用于存储键值对（key value pair）的数据结构，因为Hash  Table根据key查询value的速度很快，所以它常用于实现Map、Dictinary、Object等数据结构。如上图所示，Hash  Table内部使用一个hash函数将传入的键转换成一串数字，而这串数字将作为键值对实际的key，通过这个key查询对应的value非常快，时间复杂度将达到O(1)。Hash函数要求相同输入对应的输出必须相等，而不同输入对应的输出必须不等，相当于对每对数据打上唯一的指纹。")]),n._v(" "),t("p",[n._v("一个Hash Table通常具有下列方法：")]),n._v(" "),t("ol",[t("li",[t("code",[n._v("add")]),n._v("：增加一组键值对")]),n._v(" "),t("li",[t("code",[n._v("remove")]),n._v("：删除一组键值对")]),n._v(" "),t("li",[t("code",[n._v("lookup")]),n._v("：查找一个键对应的值")])]),n._v(" "),t("p",[t("strong",[n._v("一个简易版本的Hash Table的Javascript实现：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function hash(string, max) {\n  var hash = 0;\n  for (var i = 0; i < string.length; i++) {\n    hash += string.charCodeAt(i);\n  }\n  return hash % max;\n}\n\nfunction HashTable() {\n  let storage = [];\n  const storageLimit = 4;\n\n  this.add = function (key, value) {\n    var index = hash(key, storageLimit);\n    if (storage[index] === undefined) {\n      storage[index] = [\n        [key, value]\n      ];\n    } else {\n      var inserted = false;\n      for (var i = 0; i < storage[index].length; i++) {\n        if (storage[index][i][0] === key) {\n          storage[index][i][1] = value;\n          inserted = true;\n        }\n      }\n      if (inserted === false) {\n        storage[index].push([key, value]);\n      }\n    }\n  }\n\n  this.remove = function (key) {\n    var index = hash(key, storageLimit);\n    if (storage[index].length === 1 && storage[index][0][0] === key) {\n      delete storage[index];\n    } else {\n      for (var i = 0; i < storage[index]; i++) {\n        if (storage[index][i][0] === key) {\n          delete storage[index][i];\n        }\n      }\n    }\n  }\n\n  this.lookup = function (key) {\n    var index = hash(key, storageLimit);\n    if (storage[index] === undefined) {\n      return undefined;\n    } else {\n      for (var i = 0; i < storage[index].length; i++) {\n        if (storage[index][i][0] === key) {\n          return storage[index][i][1];\n        }\n      }\n    }\n  }\n}\n")])])]),t("h3",{attrs:{id:"_6-tree（树）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-tree（树）","aria-hidden":"true"}},[n._v("#")]),n._v(" 6. Tree（树）")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-tree.png",alt:"img"}})]),n._v(" "),t("p",[n._v("顾名思义，Tree的数据结构和自然界中的树极其相似，有根、树枝、叶子，如上图所示。Tree是一种多层数据结构，与Array、Stack、Queue相比是一种非线性的数据结构，在进行插入和搜索操作时很高效。在描述一个Tree时经常会用到下列概念：")]),n._v(" "),t("ol",[t("li",[n._v("Root（根）：代表树的根节点，根节点没有父节点")]),n._v(" "),t("li",[n._v("Parent Node（父节点）：一个节点的直接上级节点，只有一个")]),n._v(" "),t("li",[n._v("Child Node（子节点）：一个节点的直接下级节点，可能有多个")]),n._v(" "),t("li",[n._v("Siblings（兄弟节点）：具有相同父节点的节点")]),n._v(" "),t("li",[n._v("Leaf（叶节点）：没有子节点的节点")]),n._v(" "),t("li",[n._v("Edge（边）：两个节点之间的连接线")]),n._v(" "),t("li",[n._v("Path（路径）：从源节点到目标节点的连续边")]),n._v(" "),t("li",[n._v("Height of Node（节点的高度）：表示节点与叶节点之间的最长路径上边的个数")]),n._v(" "),t("li",[n._v("Height of Tree（树的高度）：即根节点的高度")]),n._v(" "),t("li",[n._v("Depth of Node（节点的深度）：表示从根节点到该节点的边的个数")]),n._v(" "),t("li",[n._v("Degree of Node（节点的度）：表示子节点的个数")])]),n._v(" "),t("p",[n._v("我们以二叉查找树为例，展示树在Javascript中的实现。在二叉查找树中，即每个节点最多只有两个子节点，而左侧子节点小于当前节点，而右侧子节点大于当前节点，如图所示：")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-BST.png",alt:"img"}})]),n._v(" "),t("p",[n._v("一个二叉查找树应该具有以下常用方法：")]),n._v(" "),t("ol",[t("li",[t("code",[n._v("add")]),n._v("：向树中插入一个节点")]),n._v(" "),t("li",[t("code",[n._v("findMin")]),n._v("：查找树中最小的节点")]),n._v(" "),t("li",[t("code",[n._v("findMax")]),n._v("：查找树中最大的节点")]),n._v(" "),t("li",[t("code",[n._v("find")]),n._v("：查找树中的某个节点")]),n._v(" "),t("li",[t("code",[n._v("isPresent")]),n._v("：判断某个节点在树中是否存在")]),n._v(" "),t("li",[t("code",[n._v("remove")]),n._v("：移除树中的某个节点")])]),n._v(" "),t("p",[n._v("以下是二叉查找树的Javascript实现：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Node {\n  constructor(data, left = null, right = null) {\n    this.data = data;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nclass BST {\n  constructor() {\n    this.root = null;\n  }\n\n  add(data) {\n    const node = this.root;\n    if (node === null) {\n      this.root = new Node(data);\n      return;\n    } else {\n      const searchTree = function (node) {\n        if (data < node.data) {\n          if (node.left === null) {\n            node.left = new Node(data);\n            return;\n          } else if (node.left !== null) {\n            return searchTree(node.left);\n          }\n        } else if (data > node.data) {\n          if (node.right === null) {\n            node.right = new Node(data);\n            return;\n          } else if (node.right !== null) {\n            return searchTree(node.right);\n          }\n        } else {\n          return null;\n        }\n      };\n      return searchTree(node);\n    }\n  }\n\n  findMin() {\n    let current = this.root;\n    while (current.left !== null) {\n      current = current.left;\n    }\n    return current.data;\n  }\n\n  findMax() {\n    let current = this.root;\n    while (current.right !== null) {\n      current = current.right;\n    }\n    return current.data;\n  }\n\n  find(data) {\n    let current = this.root;\n    while (current.data !== data) {\n      if (data < current.data) {\n        current = current.left\n      } else {\n        current = current.right;\n      }\n      if (current === null) {\n        return null;\n      }\n    }\n    return current;\n  }\n\n  isPresent(data) {\n    let current = this.root;\n    while (current) {\n      if (data === current.data) {\n        return true;\n      }\n      if (data < current.data) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n    return false;\n  }\n\n  remove(data) {\n    const removeNode = function (node, data) {\n      if (node == null) {\n        return null;\n      }\n      if (data == node.data) {\n        // node没有子节点\n        if (node.left == null && node.right == null) {\n          return null;\n        }\n        // node没有左侧子节点\n        if (node.left == null) {\n          return node.right;\n        }\n        // node没有右侧子节点\n        if (node.right == null) {\n          return node.left;\n        }\n        // node有两个子节点\n        var tempNode = node.right;\n        while (tempNode.left !== null) {\n          tempNode = tempNode.left;\n        }\n        node.data = tempNode.data;\n        node.right = removeNode(node.right, tempNode.data);\n        return node;\n      } else if (data < node.data) {\n        node.left = removeNode(node.left, data);\n        return node;\n      } else {\n        node.right = removeNode(node.right, data);\n        return node;\n      }\n    }\n    this.root = removeNode(this.root, data);\n  }\n}\n")])])]),t("p",[t("strong",[n._v("测试一下：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const bst = new BST();\n\nbst.add(4);\nbst.add(2);\nbst.add(6);\nbst.add(1);\nbst.add(3);\nbst.add(5);\nbst.add(7);\nbst.remove(4);\nconsole.log(bst.findMin());\nconsole.log(bst.findMax());\nbst.remove(7);\nconsole.log(bst.findMax());\nconsole.log(bst.isPresent(4));\n")])])]),t("p",[t("strong",[n._v("打印结果：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1\n7\n6\nfalse\n")])])]),t("h3",{attrs:{id:"_7-trie（字典树，读音同try）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-trie（字典树，读音同try）","aria-hidden":"true"}},[n._v("#")]),n._v(" 7. Trie（字典树，读音同try）")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-trie.png",alt:"img"}})]),n._v(" "),t("p",[n._v("Trie也可以叫做Prefix  Tree（前缀树），也是一种搜索树。Trie分步骤存储数据，树中的每个节点代表一个步骤，trie常用于存储单词以便快速查找，比如实现单词的自动完成功能。   Trie中的每个节点都包含一个单词的字母，跟着树的分支可以可以拼写出一个完整的单词，每个节点还包含一个布尔值表示该节点是否是单词的最后一个字母。")]),n._v(" "),t("p",[n._v("Trie一般有以下方法：")]),n._v(" "),t("ol",[t("li",[t("code",[n._v("add")]),n._v("：向字典树中增加一个单词")]),n._v(" "),t("li",[t("code",[n._v("isWord")]),n._v("：判断字典树中是否包含某个单词")]),n._v(" "),t("li",[t("code",[n._v("print")]),n._v("：返回字典树中的所有单词")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * Trie的节点\n */\nfunction Node() {\n  this.keys = new Map();\n  this.end = false;\n  this.setEnd = function () {\n    this.end = true;\n  };\n  this.isEnd = function () {\n    return this.end;\n  }\n}\n\nfunction Trie() {\n  this.root = new Node();\n\n  this.add = function (input, node = this.root) {\n    if (input.length === 0) {\n      node.setEnd();\n      return;\n    } else if (!node.keys.has(input[0])) {\n      node.keys.set(input[0], new Node());\n      return this.add(input.substr(1), node.keys.get(input[0]));\n    } else {\n      return this.add(input.substr(1), node.keys.get(input[0]));\n    }\n  }\n\n  this.isWord = function (word) {\n    let node = this.root;\n    while (word.length > 1) {\n      if (!node.keys.has(word[0])) {\n        return false;\n      } else {\n        node = node.keys.get(word[0]);\n        word = word.substr(1);\n      }\n    }\n    return (node.keys.has(word) && node.keys.get(word).isEnd()) ? true : false;\n  }\n\n  this.print = function () {\n    let words = new Array();\n    let search = function (node = this.root, string) {\n      if (node.keys.size != 0) {\n        for (let letter of node.keys.keys()) {\n          search(node.keys.get(letter), string.concat(letter));\n        }\n        if (node.isEnd()) {\n          words.push(string);\n        }\n      } else {\n        string.length > 0 ? words.push(string) : undefined;\n        return;\n      }\n    };\n    search(this.root, new String());\n    return words.length > 0 ? words : null;\n  }\n}\n")])])]),t("h3",{attrs:{id:"_8-graph（图）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-graph（图）","aria-hidden":"true"}},[n._v("#")]),n._v(" 8. Graph（图）")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-graph.png",alt:"img"}})]),n._v(" "),t("p",[n._v("Graph是节点（或顶点）以及它们之间的连接（或边）的集合。Graph也可以称为Network（网络）。根据节点之间的连接是否有方向又可以分为Directed  Graph（有向图）和Undrected  Graph（无向图）。Graph在实际生活中有很多用途，比如：导航软件计算最佳路径，社交软件进行好友推荐等等。")]),n._v(" "),t("p",[n._v("Graph通常有两种表达方式：")]),n._v(" "),t("p",[t("strong",[n._v("Adjaceny List（邻接列表）")]),n._v("：")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-adj-list.png",alt:"img"}})]),n._v(" "),t("p",[n._v("邻接列表可以表示为左侧是节点的列表，右侧列出它所连接的所有其他节点。")]),n._v(" "),t("p",[n._v("和 "),t("strong",[n._v("Adjacency Matrix（邻接矩阵）")]),n._v("：")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://image.fundebug.com/2019-08-12-adj-matrix.png",alt:"img"}})]),n._v(" "),t("p",[n._v("邻接矩阵用矩阵来表示节点之间的连接关系，每行或者每列表示一个节点，行和列的交叉处的数字表示节点之间的关系：0表示没用连接，1表示有连接，大于1表示不同的权重。")]),n._v(" "),t("p",[n._v("访问Graph中的节点需要使用遍历算法，遍历算法又分为广度优先和深度优先，主要用于确定目标节点和根节点之间的距离，")]),n._v(" "),t("p",[n._v("在Javascript中，Graph可以用一个矩阵（二维数组）表示，广度优先搜索算法可以实现如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function bfs(graph, root) {\n  var nodesLen = {};\n\n  for (var i = 0; i < graph.length; i++) {\n    nodesLen[i] = Infinity;\n  }\n\n  nodesLen[root] = 0;\n\n  var queue = [root];\n  var current;\n\n  while (queue.length != 0) {\n    current = queue.shift();\n\n    var curConnected = graph[current];\n    var neighborIdx = [];\n    var idx = curConnected.indexOf(1);\n    while (idx != -1) {\n      neighborIdx.push(idx);\n      idx = curConnected.indexOf(1, idx + 1);\n    }\n\n    for (var j = 0; j < neighborIdx.length; j++) {\n      if (nodesLen[neighborIdx[j]] == Infinity) {\n        nodesLen[neighborIdx[j]] = nodesLen[current] + 1;\n        queue.push(neighborIdx[j]);\n      }\n    }\n  }\n\n  return nodesLen;\n}\n")])])]),t("p",[t("strong",[n._v("测试一下：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var graph = [\n  [0, 1, 1, 1, 0],\n  [0, 0, 1, 0, 0],\n  [1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0],\n  [0, 1, 0, 0, 0]\n];\n\nconsole.log(bfs(graph, 1));\n")])])]),t("p",[t("strong",[n._v("打印：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("{\n  0: 2,\n  1: 0,\n  2: 1,\n  3: 3,\n  4: Infinity\n}\n")])])])])},[],!1,null,null,null);e.default=i.exports}}]);